# ------------------------------------------------------------------------------
# File          : csr_parser.py
# Description   : parsing the hardware csr (configuration & status register) definition file
# Author        : Ke Xu
# ------------------------------------------------------------------------------
# History        
# 1.0 06/27/2019: KE XU 		
# Initial version
#
# 1.1 07/02/2019: Jiewei Xiao
# Added header file generation 
# ------------------------------------------------------------------------------

import os
import sys
import re
import getpass
from datetime import datetime
import xml.etree.ElementTree as ET

# ------------------------------------------------------------------------------
# Macro definitions
# ------------------------------------------------------------------------------
IP_NAME = "VENUS"

# Definitions
I_XML_FILE_NAME             = 'venus_csr.xml'
O_REG_FILE_NAME             = 'venus_csr_list_autogen.txt'
O_C_HEADER_FILE_NAME        = 'venus_hw_csr_autogen.h'      			# output c/c++/systemC header
O_V_HEADER_FILE_NAME        = 'venus_hw_csr_autogen.vh'     			# output verilog header

# Driver files
O_REG_DEFAULT_FILE_NAME     = 'venus_hw_reg_default_value_autogen.h'	# output default_value header
O_REG_DEFINES_FILE_NAME     = 'venus_hw_reg_defines_autogen.h'      	# output reg_defines header
O_REG_ENUM_FILE_NAME        = 'venus_hw_reg_enum_autogen.h'         	# output reg_enum header
O_REG_TABLE_FILE_NAME       = 'venus_hw_reg_table_autogen.h'        	# output reg_table header

O_FILE_LIST = [O_REG_FILE_NAME, O_C_HEADER_FILE_NAME, O_V_HEADER_FILE_NAME,O_REG_DEFAULT_FILE_NAME,O_REG_DEFINES_FILE_NAME,O_REG_ENUM_FILE_NAME,O_REG_TABLE_FILE_NAME]

# ------------------------------------------------------------------------------
# Functions
# ------------------------------------------------------------------------------
def delete_old_o_file():
    # delete old output files first if they exist
    for o_file in O_FILE_LIST:
        if os.path.exists(o_file):
            os.remove(o_file)
            print("Deleting old " + o_file)

def gen_header(fp_o_file_list):
    for fp_o_file in fp_o_file_list:
        fp_o_file.write("// -----------------------------------------------------------------------------\n")
        fp_o_file.write("// This is the auto-generated file, do NOT modify by hand!\n")
        fp_o_file.write("// -----------------------------------------------------------------------------\n")
        fp_o_file.write("// Input source file   : " + I_XML_FILE_NAME + "\n")
        fp_o_file.write("// Script used         : " + os.path.basename(__file__) + "\n")
        fp_o_file.write("// Generated by        : " + getpass.getuser() + "\n")
        fp_o_file.write("// Generated on        : " + datetime.now().strftime('%Y-%m-%d %H:%M:%S') + "\n")
        fp_o_file.write("// -----------------------------------------------------------------------------\n")

def close_o_file(fp_o_file_list):
    for fp_o_file in fp_o_file_list:
        fp_o_file.close()
		
def gen_field_macros(fp_o_file, reg_name, field_name, field_position_msb, field_position_lsb):
	fp_o_file.write("#define %s_%s_MSB %s\n" % (reg_name, field_name, field_position_msb))
	fp_o_file.write("#define %s_%s_LSB %s\n" % (reg_name, field_name, field_position_lsb))

def gen_driver_headers(fp_o_driver_file_list):
    fp_o_driver_file_list[0].write("#include \""+O_REG_DEFINES_FILE_NAME+"\"\n")
    fp_o_driver_file_list[0].write("static const u32 hw_dec_reg_default_values["+IP_NAME+"_MAX_REG_COUNT][3] = { \n")
    fp_o_driver_file_list[1].write("#define RO    1 \n")
    fp_o_driver_file_list[1].write("#define WO    2 \n")
    fp_o_driver_file_list[1].write("#define RW    3 \n")
    fp_o_driver_file_list[1].write("#define RC    4 \n")
    fp_o_driver_file_list[1].write("#define WC    5 \n\n")

reg_count = 0

def gen_driver_headers_end(fp_o_driver_file_list):
    fp_o_driver_file_list[0].write("};\n")
    fp_o_driver_file_list[1].write("#define "+IP_NAME+"_MAX_REG_COUNT        "+str(int(reg_count))+"\n")
    fp_o_driver_file_list[1].write("#define "+IP_NAME+"_MAX_REG_ADDR         "+str(hex((reg_count-1)*4))+"\n")
    fp_o_driver_file_list[1].write("#define V100_REG_FILE_VERSION      \""+I_XML_FILE_NAME+"\"\n")


# ------------------------------------------------------------------------------
# Main process
# ------------------------------------------------------------------------------

delete_old_o_file()

fp_o_reg_file       		= open(O_REG_FILE_NAME,         "w")
fp_o_c_header_file			= open(O_C_HEADER_FILE_NAME,    "w")
fp_o_v_header_file			= open(O_V_HEADER_FILE_NAME,    "w")

# Driver files
fp_o_reg_default_value_file = open(O_REG_DEFAULT_FILE_NAME,	"w")
fp_o_reg_defines_file       = open(O_REG_DEFINES_FILE_NAME, "w")
fp_o_reg_enum_file          = open(O_REG_ENUM_FILE_NAME,    "w")
fp_o_reg_table_file         = open(O_REG_TABLE_FILE_NAME,   "w")

fp_o_file_list			= [fp_o_reg_file, fp_o_c_header_file, fp_o_v_header_file,fp_o_reg_default_value_file, fp_o_reg_defines_file, fp_o_reg_enum_file, fp_o_reg_table_file]
fp_o_driver_file_list	= [fp_o_reg_default_value_file, fp_o_reg_defines_file, fp_o_reg_enum_file, fp_o_reg_table_file]

gen_header(fp_o_file_list)

gen_driver_headers(fp_o_driver_file_list)

root = ET.parse(I_XML_FILE_NAME).getroot()

for module in root:
	module_name = module.attrib.get('name')
	for reg in module:
		reg_name    = reg.attrib.get('name')
		reg_width   = int(reg.attrib.get('width'))
		reg_offset  = int(reg.attrib.get('offset').replace('_', ''), 16)
		reg_reset   = int(reg.attrib.get('reset').replace('_', ''), 16)
		reg_access  = reg.attrib.get('access')
		
		reg_offset = reg_count * 4;
		if len(reg_name) != 0 :
			reg_count += 1
		
		fp_o_reg_file.write(reg_name + "\n")
		fp_o_c_header_file.write("\n#define " + f'{reg_name: <{32}}' + format(reg_offset, '#010x') + "\n")
		
		fp_o_reg_default_value_file.write("    { "+ format(reg_offset, '#06x') + ", " + reg_access.upper() +" , " + format(reg_reset, '#010x') +" }, \n")
		
		# for sanity check purpose
		field_total_length  = 0
		reset_total_value   = 0
		for field in reg:
			field_name              = field.attrib.get('name')
			# Field position and length
			field_position          = field.attrib.get('position')
			field_position_digit    = re.findall('\d+', field_position)
			if len(field_position_digit) == 1:
				field_position_msb = field_position_lsb = int(field_position_digit[0])
			elif len(field_position_digit) == 2:
				field_position_msb      = int(field_position_digit[0])
				field_position_lsb      = int(field_position_digit[1])
			else:
				sys.exit("Error: module = %s, reg = %s, field = %s, field position %s error! Exit..." % (
				module_name, reg_name, field_name, field_position))
			
			field_width             = int(field.attrib.get('width'))
			field_total_length      = field_total_length + field_width

			field_type              = field.attrib.get('type')
            # field reset value
			field_reset_value       = int(field.attrib.get('reset').replace('_', ''), 16) << field_position_lsb
			reset_total_value       = reset_total_value + field_reset_value

            # Sanity check: whether field_width is greater than 0
			if field_width <= 0:
				sys.exit("Error: module = %s, reg = %s, field = %s, width = %d! Exit..." % (module_name, reg_name, field_name, field_width))

            # Sanity check: whether field_position and width match
			if field_width != field_position_msb - field_position_lsb + 1:
				sys.exit("Error: module = %s, reg = %s, field = %s, position %s and width %s mismatch! Exit..." % (module_name, reg_name, field_name, field_position, str(field_width)))

			if "RESERVED" not in field_name:
				full_name = IP_NAME + "_" + reg_name + "_" + field_name
				fp_o_reg_enum_file.write("    " + full_name + ",\n")
				fp_o_reg_table_file.write( "{ " + format(reg_offset, '#06x') + ", ")
				fp_o_reg_table_file.write( format(field_width, '#2d') + ", ")
				fp_o_reg_table_file.write( format(field_position_lsb, '#2d') + ", ")
				fp_o_reg_table_file.write( reg_access.upper() + ", ")
				fp_o_reg_table_file.write( format(field_reset_value, '#010x') + " },")
				fp_o_reg_table_file.write("/* " + full_name + " */ \n" )
			
			gen_field_macros(fp_o_c_header_file, reg_name, field_name, field_position_msb, field_position_lsb)
			
		# Sanity check: whether field definition is complete
		if field_total_length != reg_width:
			sys.exit("Error: module = %s, reg = %s, field total length = %s does NOT match register width = %s! Exit..." % (module_name, reg_name, str(field_total_length), str(reg_width)))
		
		# Sanity check: whether reset value definition is correct
		if reset_total_value != reg_reset:
			sys.exit("Error: module = %s, reg = %s, field reset total value = %s does NOT match register reset value =  %s! Exit..." % (module_name, reg_name, hex(reset_total_value), hex(reg_reset)))

gen_driver_headers_end(fp_o_driver_file_list)
close_o_file(fp_o_file_list)
