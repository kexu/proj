# ------------------------------------------------------------------------------
# File          : interface_parser.py
# Description   : parsing the hardware interface definition file
# Author        : Ke Xu
# ------------------------------------------------------------------------------
# History        
# 1.0 07/10/2019: KE XU		
# Initial version
#
# 1.1 07/29/2019: KE XU
# Add the capability to parse 3D array interface (for array dimension greater
# than 3D, please either decompose into multiple 3D array or modify the script by 
# yourself!)
# Users need to specify "type" in interface definition
# e.g. <interface name="dma2con_if_map" width="432" type="array">
# e.g. <field name="array" z_dim="1" y_dim="3" x_dim="18" width="8" type="int" />
#
# ------------------------------------------------------------------------------
import os
import sys
import math
import re
import getpass
from datetime import datetime
import xml.etree.ElementTree as ET

# ------------------------------------------------------------------------------
# Macro definitions
# ------------------------------------------------------------------------------

# Definitions
I_XML_FILE_NAME             = 'venus_interface.xml'
HEADER_FILE					= 'venus_hw_interface_autogen'
O_C_HEADER_FILE_NAME        = HEADER_FILE + '.h'      			# output c/c++/systemC header
O_V_HEADER_FILE_NAME        = HEADER_FILE + '.vh'     			# output verilog header

O_FILE_LIST = [O_C_HEADER_FILE_NAME, O_V_HEADER_FILE_NAME]

WORD_SIZE					= 64
# ------------------------------------------------------------------------------
# Functions
# ------------------------------------------------------------------------------
def delete_old_o_file():
    # delete old output files first if they exist
    for o_file in O_FILE_LIST:
        if os.path.exists(o_file):
            os.remove(o_file)
            print("Deleting old " + o_file)

def gen_header(fp_o_file_list):
    for fp_o_file in fp_o_file_list:
        fp_o_file.write("// -----------------------------------------------------------------------------\n")
        fp_o_file.write("// This is the auto-generated file, do NOT modify by hand!\n")
        fp_o_file.write("// -----------------------------------------------------------------------------\n")
        fp_o_file.write("// Input source file   : " + I_XML_FILE_NAME + "\n")
        fp_o_file.write("// Script used         : " + os.path.basename(__file__) + "\n")
        fp_o_file.write("// Generated by        : " + getpass.getuser() + "\n")
        fp_o_file.write("// Generated on        : " + datetime.now().strftime('%Y-%m-%d %H:%M:%S') + "\n")
        fp_o_file.write("// -----------------------------------------------------------------------------\n")
		
def gen_interface_overview(root, fp_o_file_list):
	for fp_o_file in fp_o_file_list:
		fp_o_file.write("// -----------------------------------------------------------------------------\n")
		fp_o_file.write("// Interfaces overview: \n")
		for module in root:
			fp_o_file.write("// 		Module %s \n" % module.attrib.get('name'))
			for interface in module:
				fp_o_file.write("// 			Interface %s \n" % interface.attrib.get('name'))
		fp_o_file.write("// -----------------------------------------------------------------------------\n\n")
		
def gen_single_interface_comment_and_header(fp_o_file, if_name, if_width):
	fp_o_file.write("// -----------------------------------------------------------------------------\n")
	fp_o_file.write("// Interface %s\n" % if_name)
	fp_o_file.write("// -----------------------------------------------------------------------------\n")
	fp_o_c_header_file.write("#define " + f'{(if_name + "_BW"): <{24}}'.upper() + str(if_width) + "\n")

def gen_struct_header(fp_o_file):
	fp_o_file.write("	struct\n")
	fp_o_file.write("	{\n")
	
def proc_field_is_greater_than_empty_slot_size(fp_o_file, field_width, empty_slot_size, word_count):
	fp_o_file.write("        %s reserved: %s;\n" % (field_type, str(field_width - empty_slot_size)))
	fp_o_file.write("        } word%s;\n" % str(word_count)) 	# end of current word
	empty_slot_size = WORD_SIZE
	word_count 		= word_count + 1
	fp_o_file.write("        struct\n") 						# start of a new word
	fp_o_file.write("        {\n")
	fp_o_file.write("            %s %s: %s;\n" % (field_type, field_name, str(field_width)))
	fp_o_file.write("            %s reserved: %s;\n" % (field_type, str(empty_slot_size - field_width)))
	fp_o_file.write("        } word%s;\n" % str(word_count))	# end of word
	word_count = word_count + 1
	return (word_count)

def gen_struct_friend_function_c_header(fp_o_file, if_name):
	fp_o_file.write("\n    friend void sc_trace(sc_trace_file* tf, const %s& v, const std::string& name);\n" % if_name.upper())	
	
# For field with array definitions: 
# <field name="array" z_dim="1" y_dim="3" x_dim="18" width="8" type="int" />	
def gen_single_interface_c_header_array(fp_o_file, module, interface, if_name, if_width):
	gen_single_interface_comment_and_header(fp_o_file, if_name, if_width)
	fp_o_file.write("\nstruct %s\n" % if_name.upper())
	fp_o_file.write("{\n")
	for field in interface:
		field_name 			= field.attrib.get('name')
		field_width 		= int(field.attrib.get('width'))
		field_type  		= field.attrib.get('type')
		field_z_dim			= int(field.attrib.get('z_dim'))
		field_y_dim			= int(field.attrib.get('y_dim'))
		field_x_dim			= int(field.attrib.get('x_dim'))
		field_length		= field_z_dim * field_y_dim * field_x_dim * field_width
		if field_z_dim != 1:
			fp_o_file.write("    %s %s[%s][%s][%s];\n" % (field_type, field_name, str(field_z_dim), str(field_y_dim), str(field_x_dim)))
		else:
			fp_o_file.write("    %s %s[%s][%s];\n" % (field_type, field_name, str(field_y_dim), str(field_x_dim)))
			
	gen_struct_friend_function_c_header(fp_o_file, if_name)		
	fp_o_file.write("};\n\n")
	
def gen_single_interface_c_header_flat(fp_o_file, module, interface, if_name, if_width):
	# ------------------------------
	# Parse the xml definition file
	# ------------------------------
	if_fields_list	= []	# [(field0_name, field0_width, field0_type), (field1_name, field1_width, field1_type), ...]
	field_total_width = 0
	for field in interface:
		field_name 			= field.attrib.get('name')
		field_width 		= int(field.attrib.get('width'))
		field_total_width	= field_total_width + field_width
		field_type  		= field.attrib.get('type')
			
		# Field position and length
		field_position          = field.attrib.get('position')
		field_position_digit    = re.findall('\d+', field_position)
		if len(field_position_digit) == 1:
			field_position_msb = field_position_lsb = int(field_position_digit[0])
		elif len(field_position_digit) == 2:
			field_position_msb      = int(field_position_digit[0])
			field_position_lsb      = int(field_position_digit[1])
		else:
			sys.exit("Error: module = %s, interface = %s, field = %s, field position %s error! Exit..." % (module_name, if_name, field_name, field_position))
				
		# Sanity check: whether field_type is uint or int
		if field_type != "uint" and field_type != "int":
			sys.exit("Error: module = %s, interface = %s, field = %s, type = %s - should be either uint or int! Exit..." % (module_name, if_name, field_name, field_type))
			
		# Sanity check: whether field_width is greater than 0
		if field_width <= 0:
			sys.exit("Error: module = %s, interface = %s, field = %s, width = %d! Exit..." % (module_name, if_name, field_name, field_width))
	
		# Sanity check: whether field_position and width match
		if field_width != field_position_msb - field_position_lsb + 1:
			sys.exit("Error: module = %s, interface = %s, field = %s, position %s and width %s mismatch! Exit..." % (module_name, if_name, field_name, field_position, str(field_width)))
				
		# Append current field to list only when sanity checks are passed
		if_fields_list.append((field_name, field_width, field_type))
						
	# Sanity check: whether field definition is complete
	if field_total_width != if_width:
		sys.exit("Error: module = %s, interface = %s, field total width = %s does NOT match interface width = %s! Exit..." % (module_name, if_name, str(field_total_width), str(if_width)))	
	
	# ------------------------------
	# Generate the header file
	# ------------------------------
	gen_single_interface_comment_and_header(fp_o_file, if_name, if_width)
		
	fp_o_file.write("\nunion %s\n" % if_name.upper())
	fp_o_file.write("{\n")
	fp_o_file.write("    struct\n")
	fp_o_file.write("    {\n")
	
	empty_slot_size = WORD_SIZE
	word_count 		= 0
	for i, field in enumerate(if_fields_list):
		field_name 	= field[0]
		field_width = field[1]
		field_type 	= field[2].upper() + str(WORD_SIZE)
		
		# last field in current interface
		if i == len(if_fields_list) - 1:
			if field_width <= empty_slot_size:
				fp_o_file.write("            %s %s: %s;\n" % (field_type, field_name, str(field_width)))
				if empty_slot_size - field_width > 0:  # reserved field inserted
					fp_o_file.write("            %s reserved: %s;\n" % (field_type, str(empty_slot_size - field_width)))
				fp_o_file.write("        } word%s;\n" % str(word_count))	# end of word
				word_count = word_count + 1
			else:	# end of current word first, then start a new word and then end it 
				word_count = proc_field_is_greater_than_empty_slot_size(fp_o_file, field_width, empty_slot_size, word_count)
		# Not last field in current interface
		else:
			if empty_slot_size == WORD_SIZE: 	# start of a new word
				fp_o_file.write("        struct\n")
				fp_o_file.write("        {\n")
				fp_o_file.write("            %s %s: %s;\n" % (field_type, field_name, str(field_width)))
				empty_slot_size = empty_slot_size - field_width
			else:								# not the start of a new word
				if field_width <= empty_slot_size: 	# store field in current word 
					fp_o_file.write("            %s %s: %s;\n" % (field_type, field_name, str(field_width)))
					empty_slot_size = empty_slot_size - field_width
					if empty_slot_size == 0:
						fp_o_file.write("        } word%s;\n" % str(word_count))
						word_count = word_count + 1
						empty_slot_size = WORD_SIZE
				else:
					word_count = proc_field_is_greater_than_empty_slot_size(fp_o_file, field_width, empty_slot_size, word_count)
		
	fp_o_file.write("    } packet_structs;\n")
	fp_o_file.write("    UINT%s packet_words[%s];\n" % (str(WORD_SIZE), str(word_count)))
	# Generate friend function sc_trace here
	gen_struct_friend_function_c_header(fp_o_file, if_name)
	fp_o_file.write("};\n\n")
		
def gen_single_interface_v_header(if_fields_list, fp_o_v_header_file):
	gen_single_interface_comment(if_fields_list[0][0], fp_o_v_header_file)
				
def close_o_file(fp_o_file_list):
    for fp_o_file in fp_o_file_list:
        fp_o_file.close()

# ------------------------------------------------------------------------------
# Main process
# ------------------------------------------------------------------------------

delete_old_o_file()

fp_o_c_header_file = open(O_C_HEADER_FILE_NAME,    "w")
fp_o_v_header_file = open(O_V_HEADER_FILE_NAME,    "w")

fp_o_file_list = [fp_o_c_header_file, fp_o_v_header_file]

gen_header(fp_o_file_list)

fp_o_c_header_file.write("\n#ifndef _%s_H_\n" % HEADER_FILE.upper())
fp_o_c_header_file.write("#define _%s_H_\n" % HEADER_FILE.upper())
fp_o_c_header_file.write("\n#include <systemc.h>\n")
fp_o_c_header_file.write("#include \"venus_hw_defs.h\"\n\n")

root = ET.parse(I_XML_FILE_NAME).getroot()

gen_interface_overview(root, fp_o_file_list)

for module in root:
	module_name = module.attrib.get('name')
	for interface in module:
		if_name 		= interface.attrib.get('name')
		if_width		= int(interface.attrib.get('width'))
		if_type			= interface.attrib.get('type')
		
		# Sanity check: whether type is "array" or "flat"
		if if_type != "array" and if_type != "flat":
			sys.exit("Error: module = %s, interface = %s, type = %s error! Type should be either \"array\" or \"flat\"! Exit..." % (module_name, if_name, if_type))
		
		if if_type == "array":
			gen_single_interface_c_header_array(fp_o_c_header_file, module, interface, if_name, if_width) 
		else:
			gen_single_interface_c_header_flat(fp_o_c_header_file, module, interface, if_name, if_width) 
		
fp_o_c_header_file.write("#endif\n")		
close_o_file(fp_o_file_list)
